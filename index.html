<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ArchScope ‚Äî AI Building Analysis</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root{--primary:#667eea;--primary2:#764ba2;--bg:#0f1220;--card:#14182b;--muted:#a7adcf}
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:radial-gradient(1200px 800px at 10% -10%, rgba(118,75,162,.25), transparent 60%), radial-gradient(1000px 800px at 110% 10%, rgba(102,126,234,.25), transparent 60%), #0c0f1e;color:#e8ebff}
    .container{max-width:1100px;margin:0 auto;padding:24px}
    .center{min-height:70vh;display:flex;flex-direction:column;align-items:center;justify-content:center}
    .hero{margin:0 0 16px;display:flex;gap:16px;align-items:center;justify-content:center}
    .logo{display:flex;align-items:center;justify-content:center;width:48px;height:48px;border-radius:14px;background:linear-gradient(135deg,rgba(102,126,234,.25),rgba(118,75,162,.25));border:1px solid rgba(255,255,255,.08);box-shadow:0 10px 28px rgba(102,126,234,.25)}
    .title{font-size:28px;font-weight:800;background:linear-gradient(90deg,var(--primary),var(--primary2));-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin:0 0 2px}
    .subtitle{margin:0;color:#b8bde8}
    .searchCard{margin:0 auto;width:650px;max-width:100%;background:transparent;border:none;padding:0 8px}
    .searchRow{display:flex;gap:10px;align-items:center;background:#0c1326;border:1px solid rgba(255,255,255,.10);border-radius:22px;padding:12px 14px;box-shadow:0 8px 30px rgba(0,0,0,.35);height:92px}
    .input{flex:1;background:transparent;border:none;height:100%;color:#e8ebff;padding:0 18px;font-size:18px;outline:none}
    .input::placeholder{color:#8d95c9}
    .input:focus{outline:none}
    .btn{height:56px;padding:0 24px;border:none;border-radius:16px;background:linear-gradient(90deg,var(--primary),var(--primary2));color:#fff;font-weight:800;cursor:pointer;box-shadow:0 12px 30px rgba(102,126,234,.30)}
    .btn:hover{filter:brightness(1.06)}
    .icon-btn{min-width:56px;width:56px;height:56px;display:flex;align-items:center;justify-content:center;padding:0;border:none;border-radius:14px;background:#22d3ee;color:#0b1220;box-shadow:0 10px 24px rgba(34,211,238,.35);cursor:pointer}
    @media (max-width:720px){
      .searchCard{width:100%;}
      .searchRow{height:auto}
      .input{height:56px}
    }
    .icon-btn:hover{filter:brightness(1.05)}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .row{display:flex;gap:12px;margin-top:12px;align-items:center;flex-wrap:wrap;position:relative}
    .uploader{position:relative;display:flex;align-items:center;gap:10px;padding:10px 12px;border:1px dashed rgba(255,255,255,.18);border-radius:12px;background:#0f1428;color:#cdd3ff}
    .file{display:none}
    .dropdown{position:relative}
    .dd-btn{height:42px;padding:0 14px;border:1px solid rgba(255,255,255,.12);border-radius:12px;background:#0f1428;color:#cdd3ff;cursor:pointer}
    .dd-menu{position:absolute;top:48px;left:0;background:#0f1428;border:1px solid rgba(255,255,255,.12);border-radius:12px;min-width:320px;box-shadow:0 10px 30px rgba(0,0,0,.4);z-index:10;display:none;max-height:280px;overflow:auto}
    .dd-item{display:block;width:100%;text-align:left;padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.06);color:#cdd3ff;background:transparent;cursor:pointer}
    .dd-item:hover{background:#121a37}
    .results{margin:24px auto;max-width:900px;display:none}
    .card{background:#0f1428;border:1px solid rgba(255,255,255,.08);border-radius:22px;padding:24px;box-shadow:0 14px 40px rgba(0,0,0,.45);overflow-wrap:break-word;word-wrap:break-word;max-width:100%;box-sizing:border-box}
    .meta{display:flex;align-items:center;gap:10px;color:#9aa3da;font-size:13px;margin-bottom:12px}
    .prose{color:#e8ebff;line-height:1.75;font-size:16px;overflow-wrap:break-word;word-wrap:break-word;max-width:100%;box-sizing:border-box}
    .prose h1,.prose h2,.prose h3{margin:18px 0 10px;color:#dbe0ff}
    .prose p{margin:10px 0;overflow-wrap:break-word;word-wrap:break-word}
    .prose strong{color:#ffffff}
    .prose ul{padding-left:22px;overflow-wrap:break-word}
    .prose li{margin:6px 0;overflow-wrap:break-word;word-wrap:break-word}
    .prose *{max-width:100%;box-sizing:border-box}
    .issue{background:#17110a;border-left:4px solid #ffb020;padding:10px;border-radius:10px;margin:10px 0}
    .rec{background:#0c2130;border-left:4px solid #27c1ff;padding:10px;border-radius:10px;margin:10px 0}
    .footer{margin:40px 0;color:#9aa3da;text-align:center}
    .hidden{display:none}
    .login-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:radial-gradient(1200px 800px at 10% -10%, rgba(118,75,162,.3), transparent 60%), radial-gradient(1000px 800px at 110% 10%, rgba(102,126,234,.3), transparent 60%), #0c0f1e;display:flex;align-items:center;justify-content:center;z-index:1000}
    .login-card{background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.04));border:1px solid rgba(255,255,255,.12);border-radius:24px;padding:40px;max-width:420px;width:90%;box-shadow:0 20px 50px rgba(0,0,0,.45)}
    .login-title{font-size:32px;font-weight:800;background:linear-gradient(90deg,var(--primary),var(--primary2));-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin:0 0 8px;text-align:center}
    .login-subtitle{color:#b8bde8;text-align:center;margin:0 0 32px;font-size:15px}
    .login-input{width:100%;background:#0f1428;border:1px solid rgba(255,255,255,.12);border-radius:14px;height:52px;color:#e8ebff;padding:0 18px;font-size:16px;margin-bottom:16px;outline:none}
    .login-input:focus{outline:2px solid rgba(102,126,234,.4);outline-offset:2px}
    .login-btn{width:100%;height:52px;border:none;border-radius:14px;background:linear-gradient(90deg,var(--primary),var(--primary2));color:#fff;font-weight:700;cursor:pointer;box-shadow:0 12px 30px rgba(102,126,234,.35);font-size:16px}
    .login-btn:hover{filter:brightness(1.06)}
    .main-content{display:none}
    .main-content.active{display:block}
    .problem-card{background:#2a1515;border:1px solid #ff4444;border-left:5px solid #ff4444;border-radius:16px;padding:18px;margin:16px 0;box-shadow:0 4px 12px rgba(255,68,68,.2);overflow-wrap:break-word;word-wrap:break-word;max-width:100%;box-sizing:border-box}
    .problem-title{color:#ff6666;font-weight:700;font-size:18px;margin:0 0 12px}
    .problem-content{color:#ffaaaa;line-height:1.7;overflow-wrap:break-word;word-wrap:break-word;max-width:100%;word-break:break-word}
    .problem-card *{max-width:100%;overflow-wrap:break-word;word-wrap:break-word;word-break:break-word}
    .main-problem{color:#ff4444!important;font-weight:700;background:rgba(255,68,68,.15);padding:4px 8px;border-radius:4px;display:inline-block;margin:4px 0}
    .potential-consequences{color:#ff6666!important;font-weight:600}
    .solution-card{background:#0f2330;border:1px solid #27c1ff;border-left:5px solid #27c1ff;border-radius:16px;padding:18px;margin:16px 0;box-shadow:0 4px 12px rgba(39,193,255,.2)}
    .solution-title{color:#66d9ff;font-weight:700;font-size:18px;margin:0 0 12px}
    .solution-content{color:#aaddff;line-height:1.7}
    .logout-btn{position:fixed;top:20px;right:20px;padding:8px 16px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);border-radius:10px;color:#cdd3ff;font-size:14px;font-weight:500;cursor:pointer;transition:all 0.2s;z-index:100}
    .logout-btn:hover{background:rgba(255,255,255,.12);color:#ffffff}
    .download-btn{display:inline-flex;align-items:center;padding:12px 24px;background:linear-gradient(90deg,var(--primary),var(--primary2));color:#fff;border:none;border-radius:12px;font-weight:600;cursor:pointer;box-shadow:0 8px 20px rgba(102,126,234,.3);transition:all 0.2s}
    .download-btn:hover{filter:brightness(1.1);transform:translateY(-1px);box-shadow:0 10px 24px rgba(102,126,234,.4)}
    .stage-badge{display:inline-block;padding:6px 12px;background:rgba(102,126,234,.2);border:1px solid rgba(102,126,234,.4);border-radius:8px;color:#9fb0ff;font-size:13px;font-weight:600;margin-left:10px}
  </style>
</head>
<body>
  <div id="loginOverlay" class="login-overlay">
    <div class="login-card">
      <h1 class="login-title">ArchScope</h1>
      <p class="login-subtitle">AI-Powered Building Analysis</p>
      <input id="loginUser" class="login-input" type="text" placeholder="Username" autocomplete="username"/>
      <input id="loginPass" class="login-input" type="password" placeholder="Password" autocomplete="current-password"/>
      <button id="loginBtn" class="login-btn">Sign In</button>
    </div>
  </div>
  <div id="mainContent" class="main-content">
  <button id="logoutBtn" class="logout-btn">Logout</button>
  <div class="container">
    <div class="center">
    <div class="hero">
      <div class="logo">
        <svg width="28" height="28" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <defs>
            <linearGradient id="g" x1="0" y1="0" x2="48" y2="48">
              <stop stop-color="#667eea"/>
              <stop offset="1" stop-color="#764ba2"/>
            </linearGradient>
          </defs>
          <path d="M8 36 L24 8 L40 36" stroke="url(#g)" stroke-width="3.5" fill="none" stroke-linecap="round"/>
          <path d="M14 28 H34" stroke="#9fb0ff" stroke-width="3" stroke-linecap="round"/>
          <path d="M10 36 H38" stroke="#bfc8ff" stroke-width="2" stroke-linecap="round"/>
        </svg>
      </div>
      <div>
        <h1 class="title">ArchScope</h1>
       
      </div>
    </div>

    <div class="searchCard">
      <div class="searchRow">
        <input id="query" class="input" type="text" placeholder="Ask anything about your building (press Enter)‚Ä¶" />
        <button id="go" class="icon-btn" aria-label="Search">
          <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <circle cx="11" cy="11" r="7" stroke="#0b1220" stroke-width="2"/>
            <path d="M20 20l-3.5-3.5" stroke="#0b1220" stroke-width="2" stroke-linecap="round"/>
          </svg>
        </button>
      </div>
      <div class="row">
        <label class="uploader">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M12 16V7m0 0l-3 3m3-3l3 3" stroke="#cdd3ff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M20 16.5a4.5 4.5 0 00-4.5-4.5h-1A5.5 5.5 0 109 17h7" stroke="#cdd3ff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
          <span id="fileLabel">Attach image (optional)</span>
          <input id="file" class="file" type="file" accept="image/png,image/jpeg" />
        </label>
        <div class="dropdown">
          <button id="ddBtn" class="dd-btn">Suggestions ‚ñæ</button>
          <div id="ddMenu" class="dd-menu">
            <button class="dd-item" data-q="foundation cracks near drainage">Foundation cracks near drainage</button>
            <button class="dd-item" data-q="roof flashing and ventilation issues">Roof flashing and ventilation issues</button>
            <button class="dd-item" data-q="electrical panel code compliance">Electrical panel code compliance</button>
            <button class="dd-item" data-q="uneven flooring and drywall seams">Uneven flooring and drywall seams</button>
            <button class="dd-item" data-q="is rebar placement adequate for this span?">Rebar placement adequacy</button>
            <button class="dd-item" data-q="any safety risks for workers visible here?">Visible safety risks</button>
          </div>
        </div>
      </div>
    </div>
    </div>

    <div id="results" class="results">
      <div class="card" id="resultCard">
        <div class="meta">
          <span>Gemini 2.0 Flash</span>
          <span>‚Ä¢</span>
          <span id="ts"></span>
          <span id="stageBadge" class="stage-badge hidden"></span>
        </div>
        <div id="status" class="sectionTitle hidden">Working‚Ä¶</div>
        <div id="markdown" class="prose"></div>
        <div id="downloadSection" class="hidden" style="margin-top:24px;padding-top:24px;border-top:1px solid rgba(255,255,255,.1);text-align:center">
          <button id="downloadBtn" class="download-btn">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-right:8px">
              <path d="M12 15V3m0 0L9 6m3-3l3 3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M3 15v3a2 2 0 002 2h14a2 2 0 002-2v-3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            Download Report
          </button>
        </div>
      </div>
    </div>

    
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script>
    // CONFIG ‚Äî you asked to hardcode for test use
    const GEMINI_API_KEY = "AIzaSyD9AqMnpmyZ2bd3tcRstyvT0F_FbqCxRAg";
    const ENDPOINT = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

    const qs = (s)=>document.querySelector(s);
    
    // Login logic
    const loginOverlay = qs('#loginOverlay');
    const mainContent = qs('#mainContent');
    const loginBtn = qs('#loginBtn');
    const loginUser = qs('#loginUser');
    const loginPass = qs('#loginPass');
    
    // By default, hide main content and show login
    mainContent.classList.remove('active');
    
    // Check if already logged in - if not, show login
    const isLoggedIn = localStorage.getItem('archscope_logged_in') === 'true';
    if(isLoggedIn){
      loginOverlay.style.display = 'none';
      mainContent.style.display = 'block';
      mainContent.classList.add('active');
    } else {
      // Force show login, hide main content
      loginOverlay.style.display = 'flex';
      mainContent.style.display = 'none';
      mainContent.classList.remove('active');
    }
    
    loginBtn.addEventListener('click',()=>{
      // Accept any username/password combination
      localStorage.setItem('archscope_logged_in', 'true');
      loginOverlay.style.display = 'none';
      mainContent.style.display = 'block';
      mainContent.classList.add('active');
    });
    
    loginPass.addEventListener('keydown',(e)=>{
      if(e.key === 'Enter') loginBtn.click();
    });
    
    loginUser.addEventListener('keydown',(e)=>{
      if(e.key === 'Enter') loginPass.focus();
    });
    
    // Logout functionality
    const logoutBtn = qs('#logoutBtn');
    logoutBtn.addEventListener('click',()=>{
      localStorage.removeItem('archscope_logged_in');
      loginOverlay.style.display = 'flex';
      mainContent.style.display = 'none';
      mainContent.classList.remove('active');
      // Clear form fields
      loginUser.value = '';
      loginPass.value = '';
    });
    
    const queryEl = qs('#query');
    const goEl = qs('#go');
    const fileEl = qs('#file');
    const fileLabel = qs('#fileLabel');
    const results = qs('#results');
    const statusEl = qs('#status');
    const mdEl = qs('#markdown');
    const tsEl = qs('#ts');
    const downloadSection = qs('#downloadSection');
    const downloadBtn = qs('#downloadBtn');
    const stageBadge = qs('#stageBadge');
    
    let currentAnalysisText = '';

    // Suggestions dropdown
    const ddBtn = qs('#ddBtn');
    const ddMenu = qs('#ddMenu');
    ddBtn.addEventListener('click',()=>{
      ddMenu.style.display = ddMenu.style.display==='block' ? 'none' : 'block';
    });
    ddMenu.addEventListener('click',(e)=>{
      if(e.target.matches('.dd-item')){
        queryEl.value = e.target.dataset.q;
        ddMenu.style.display = 'none';
        queryEl.focus();
      }
    });
    document.addEventListener('click',(e)=>{
      if(!ddMenu.contains(e.target) && !ddBtn.contains(e.target)) ddMenu.style.display='none';
    });

    fileEl.addEventListener('change',()=>{
      const f = fileEl.files[0];
      fileLabel.textContent = f ? `Attached: ${f.name}` : 'Attach image (optional)';
    });

    queryEl.addEventListener('keydown',(e)=>{ if(e.key==='Enter'){ e.preventDefault(); goEl.click(); }});
    goEl.addEventListener('click', runAnalysis);
    
    downloadBtn.addEventListener('click', ()=>{
      if(!currentAnalysisText) return;
      const blob = new Blob([currentAnalysisText], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
      a.download = `ArchScope_Report_${timestamp}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    async function runAnalysis(){
      const userQuery = (queryEl.value || '').trim();
      if(!userQuery && fileEl.files.length === 0){
        queryEl.focus();
        queryEl.placeholder = 'Please enter a question or attach an image';
        return;
      }

      setBusy(true);
      mdEl.innerHTML = '';
      downloadSection.classList.add('hidden');
      stageBadge.classList.add('hidden');
      currentAnalysisText = '';

      try{
        const parts = [ { text: buildPrompt(userQuery) } ];

        if(fileEl.files.length){
          const file = fileEl.files[0];
          const { dataUrl, mime } = await toBase64Compressed(file, 1600, 0.85);
          parts.push({ inline_data: { mime_type: mime, data: dataUrl.split(',')[1] }});
        }

        const payload = { contents: [{ parts }] };
        const controller = new AbortController();
        const timeoutId = setTimeout(()=>controller.abort(), 60000);
        const res = await fetch(ENDPOINT, {
          method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify(payload), signal: controller.signal
        });
        clearTimeout(timeoutId);
        if(!res.ok){ throw new Error(`API error ${res.status}`); }
        const data = await res.json();

        const text = data?.candidates?.[0]?.content?.parts?.map(p=>p.text).join('\n') || 'No response.';
        currentAnalysisText = text;
        
        // Extract construction stage from response
        const stageMatch = text.match(/\*\*?Detected Stage:\*\*?\s*(.+?)(?:\n|$)/i) || 
                          text.match(/Detected Stage:\s*(.+?)(?:\n|$)/i) ||
                          text.match(/Stage:\s*(.+?)(?:\n|$)/i);
        
        if(stageMatch && stageMatch[1]){
          const detectedStage = stageMatch[1].trim();
          stageBadge.textContent = detectedStage;
          stageBadge.classList.remove('hidden');
        }
        
        renderMarkdown(text);
        downloadSection.classList.remove('hidden');
      }catch(err){
        statusEl.classList.remove('hidden');
        statusEl.textContent = `Error: ${err.message}`;
        downloadSection.classList.add('hidden');
      }finally{
        setBusy(false);
      }
    }

    function buildPrompt(query){
      return `You are a licensed civil/structural engineer performing a technical building inspection. Analyze BOTH the user's text and any attached image.\n\n`+
      `CRITICAL: Provide SPECIFIC, ACTIONABLE engineering solutions. Do NOT just say "consult a structural engineer" - YOU are the engineer. Give detailed technical recommendations with:\n`+
      `- Specific measurements, dimensions, and tolerances\n`+
      `- Material specifications (concrete grade, rebar size, fastener types, etc.)\n`+
      `- Step-by-step remediation procedures\n`+
      `- Code references where applicable (IRC, IBC, ACI, etc.)\n`+
      `- Load calculations if structural issues are identified\n`+
      `- Construction methods and sequence\n\n`+
      `Classify which construction stage best matches: Foundation & Sitework, Framing & Structure, Electrical Systems, Plumbing Systems, Roofing & Insulation, Interior Finishing.\n`+
      `Output the first line as: **Detected Stage:** <stage>\n\n`+
      `Provide a detailed engineering report with:\n`+
      `## 1. Overall Assessment\n`+
      `Technical evaluation of current condition with specific observations.\n\n`+
      `## 2. Detected Deficiencies (with Severity)\n`+
      `For each issue:\n`+
      `- Location and extent (with measurements if visible)\n`+
      `- Severity: Low/Medium/High/Critical\n`+
      `- Root cause analysis\n`+
      `- Potential consequences if unaddressed\n\n`+
      `## 3. Remediation Solutions\n`+
      `For EACH deficiency, provide:\n`+
      `- Specific repair method with step-by-step instructions\n`+
      `- Required materials (with specifications: sizes, grades, quantities)\n`+
      `- Tools and equipment needed\n`+
      `- Estimated dimensions/thickness for repairs\n`+
      `- Installation sequence and curing times if applicable\n`+
      `- Cost considerations (material vs labor intensive)\n\n`+
      `## 4. Compliance & Code Status\n`+
      `- Code violations identified (cite specific codes: IRC, IBC, NEC, UPC, etc.)\n`+
      `- Safety concerns with priority ranking\n`+
      `- Required permits for remediation work\n\n`+
      `User Query Focus: ${query || 'Comprehensive stage-specific analysis'}\n\n`+
      `Format response in clear Markdown with headings. Be technical, specific, and actionable.`;
    }

    function setBusy(b){
      goEl.disabled = b;
      results.style.display = 'block';
      statusEl.classList.remove('hidden');
      statusEl.textContent = b ? 'Analyzing with Gemini‚Ä¶' : '';
      if(!b) statusEl.classList.add('hidden');
      tsEl.textContent = new Date().toLocaleTimeString();
    }

    function renderMarkdown(text){
      if(!text) return;
      
      // Parse text to extract problems and solutions
      const html = marked.parse(text);
      let output = '';
      
      // Split by major sections (handle both ## and ###)
      const sectionRegex = /(?:^|\n)(##?\s+[^\n]+)/g;
      const matches = [...text.matchAll(sectionRegex)];
      
      if(matches.length === 0){
        // No sections found, render as normal
        output = marked.parse(text);
      } else {
        let lastIdx = 0;
        for(let i = 0; i < matches.length; i++){
          const match = matches[i];
          const sectionStart = match.index + match[0].indexOf(match[1]);
          const sectionEnd = i < matches.length - 1 ? matches[i+1].index : text.length;
          const sectionText = text.substring(sectionStart, sectionEnd);
          const title = match[1].replace(/^##?\s+/, '').trim();
          const content = sectionText.replace(/^##?\s+[^\n]+\n*/, '').trim();
          
          // Render everything before first section
          if(i === 0 && sectionStart > 0){
            output += marked.parse(text.substring(0, sectionStart));
          }
          
          // Check if this is the deficiencies/problems section
          if(title.toLowerCase().includes('deficiency') || title.toLowerCase().includes('problem') || title.toLowerCase().includes('issue')){
            if(content){
              // Parse deficiencies line by line - look for patterns like "* **Deficiency 1:" or "* Deficiency 1:"
              const lines = content.split('\n');
              let deficiencies = [];
              let currentDef = null;
              
              lines.forEach((line) => {
                const trimmed = line.trim();
                
                // Check if this line starts a new deficiency - look for patterns like:
                // "* **Deficiency 1:", "* Deficiency 1:", "**Deficiency 1:", "Deficiency 1:"
                const defPattern = /^(?:\*\s*)?\*?\*?(?:Deficiency|Problem|Issue)\s*\d+[:\-]/i;
                
                if(defPattern.test(trimmed)){
                  // Save previous deficiency if exists
                  if(currentDef){
                    deficiencies.push(currentDef);
                  }
                  // Start new deficiency
                  currentDef = trimmed;
                } else if(currentDef){
                  // Continue adding to current deficiency (all sub-items)
                  currentDef += '\n' + trimmed;
                } else if(trimmed.length > 0 && /deficiency|problem|issue|severity|location/i.test(trimmed)){
                  // Start accumulating if we see deficiency-related content
                  currentDef = trimmed;
                }
              });
              
              // Don't forget the last one
              if(currentDef){
                deficiencies.push(currentDef);
              }
              
              // Clean and filter - ensure we have actual deficiencies
              deficiencies = deficiencies.map(def => def.trim()).filter(def => {
                const lower = def.toLowerCase();
                return def.length > 30 && (
                  lower.includes('deficiency') || 
                  lower.includes('severity') || 
                  lower.includes('location') ||
                  lower.includes('root cause')
                );
              });
              
              if(deficiencies.length > 0){
                deficiencies.forEach((def, idx) => {
                  const defContent = def.trim();
                  if(defContent){
                    // Extract deficiency name - handle formats like:
                    // "* **Deficiency 1: Name**" or "Deficiency 1: Name (Severity: X)"
                    let defName = `Deficiency ${idx + 1}`;
                    
                    // Try to extract from first line
                    const firstLine = defContent.split('\n')[0];
                    // Match: "* **Deficiency 1: Name**" or "Deficiency 1: Name"
                    const nameMatch = firstLine.match(/(?:Deficiency|Problem|Issue)\s*\d+[:\-]\s*\*?\*?([^*\n(]+?)\*?\*?/i);
                    if(nameMatch){
                      defName = nameMatch[1].trim();
                      // Remove markdown bold markers if any
                      defName = defName.replace(/\*\*/g, '').trim();
                    } else {
                      // Fallback: try without asterisks
                      const simpleMatch = firstLine.match(/(?:Deficiency|Problem|Issue)\s*\d+[:\-]\s*([^\n(*]+)/i);
                      if(simpleMatch){
                        defName = simpleMatch[1].trim();
                      }
                    }
                    
                    const parsedDef = marked.parse(defContent);
                    output += `<div class="problem-card"><div class="problem-title">‚ö†Ô∏è ${defName}</div><div class="problem-content">${parsedDef}</div></div>`;
                  }
                });
              } else {
                // Fallback: single card if no numbered deficiencies found
                const parsedContent = marked.parse(content);
                output += `<div class="problem-card"><div class="problem-title">‚ö†Ô∏è ${title}</div><div class="problem-content">${parsedContent}</div></div>`;
              }
            }
            continue;
          }
          
          // Check if this is the solutions/remediation section
          if(title.toLowerCase().includes('remediation') || title.toLowerCase().includes('solution') || title.toLowerCase().includes('recommendation')){
            if(content){
              // Split into individual solutions - look for numbered solutions or "For EACH deficiency"
              let solutions = content.split(/\n(?=\*\s+\*?\*?(?:Solution|Remediation|Recommendation)\s*\d+[:\-]|For\s+EACH\s+deficiency)/i);
              
              // If no matches, try splitting by bullet points
              if(solutions.length <= 1){
                solutions = content.split(/\n(?=\*)/).filter(line => 
                  line.toLowerCase().includes('solution') || 
                  line.toLowerCase().includes('remediation') ||
                  line.toLowerCase().includes('recommendation') ||
                  line.toLowerCase().includes('repair method') ||
                  line.toLowerCase().includes('required materials')
                );
              }
              
              solutions = solutions.map(sol => sol.trim()).filter(sol => sol.length > 30);
              
              if(solutions.length > 0){
                solutions.forEach((sol, idx) => {
                  const solContent = sol.trim();
                  if(solContent){
                    // Extract solution name if available
                    const nameMatch = solContent.match(/(?:Solution|Remediation|Recommendation)\s*\d+[:\-]\s*([^\n(*]+)/i);
                    const solName = nameMatch ? nameMatch[1].trim() : `Solution ${idx + 1}`;
                    const parsedSol = marked.parse(solContent);
                    output += `<div class="solution-card"><div class="solution-title">üîß ${solName}</div><div class="solution-content">${parsedSol}</div></div>`;
                  }
                });
              } else {
                // Fallback: single card if no numbered solutions found
                const parsedContent = marked.parse(content);
                output += `<div class="solution-card"><div class="solution-title">üîß ${title}</div><div class="solution-content">${parsedContent}</div></div>`;
              }
            }
            continue;
          }
          
          // Other sections render normally
          output += marked.parse(sectionText);
        }
      }
      
      // Fallback: if no structured parsing worked, try to find problems/solutions in full text
      if(!output){
        const lower = text.toLowerCase();
        const probIdx = lower.indexOf('deficiency') !== -1 ? lower.indexOf('deficiency') : 
                       lower.indexOf('problem') !== -1 ? lower.indexOf('problem') : -1;
        const solIdx = lower.indexOf('remediation') !== -1 ? lower.indexOf('remediation') :
                      lower.indexOf('solution') !== -1 ? lower.indexOf('solution') : -1;
        
        if(probIdx !== -1 && solIdx !== -1){
          const beforeProb = text.substring(0, probIdx);
          let problemSection = text.substring(probIdx, solIdx);
          const solutionSection = text.substring(solIdx);
          
          // Split problems into individual cards using improved line-by-line parsing
          const lines = problemSection.split('\n');
          let deficiencies = [];
          let currentDef = null;
          
          lines.forEach((line) => {
            const trimmed = line.trim();
            const defPattern = /^(?:\*\s*)?\*?\*?(?:Deficiency|Problem|Issue)\s*\d+[:\-]/i;
            
            if(defPattern.test(trimmed)){
              if(currentDef) deficiencies.push(currentDef);
              currentDef = trimmed;
            } else if(currentDef){
              currentDef += '\n' + trimmed;
            } else if(trimmed.length > 0 && /deficiency|problem|issue|severity|location/i.test(trimmed)){
              currentDef = trimmed;
            }
          });
          
          if(currentDef) deficiencies.push(currentDef);
          
          deficiencies = deficiencies.map(def => def.trim()).filter(def => {
            const lower = def.toLowerCase();
            return def.length > 30 && (
              lower.includes('deficiency') || 
              lower.includes('severity') || 
              lower.includes('location') ||
              lower.includes('root cause')
            );
          });
          
          // Split solutions into individual cards
          let solutions = solutionSection.split(/\n(?=\*\s+\*?\*?(?:Solution|Remediation|Recommendation)\s*\d+[:\-])/i);
          if(solutions.length <= 1){
            solutions = solutionSection.split(/\n(?=\*)/).filter(line => 
              line.toLowerCase().includes('solution') || line.toLowerCase().includes('remediation'));
          }
          solutions = solutions.map(sol => sol.trim()).filter(sol => sol.length > 30);
          
          output += marked.parse(beforeProb);
          
          // Create individual problem cards
          if(deficiencies.length > 0){
            deficiencies.forEach((def, idx) => {
              let defName = `Deficiency ${idx + 1}`;
              const firstLine = def.split('\n')[0];
              const nameMatch = firstLine.match(/(?:Deficiency|Problem|Issue)\s*\d+[:\-]\s*\*?\*?([^*\n(]+?)\*?\*?/i);
              if(nameMatch){
                defName = nameMatch[1].trim().replace(/\*\*/g, '').trim();
              } else {
                const simpleMatch = firstLine.match(/(?:Deficiency|Problem|Issue)\s*\d+[:\-]\s*([^\n(*]+)/i);
                if(simpleMatch){
                  defName = simpleMatch[1].trim();
                }
              }
              output += `<div class="problem-card"><div class="problem-title">‚ö†Ô∏è ${defName}</div><div class="problem-content">${marked.parse(def)}</div></div>`;
            });
          } else {
            output += `<div class="problem-card"><div class="problem-title">‚ö†Ô∏è Detected Deficiencies</div><div class="problem-content">${marked.parse(problemSection)}</div></div>`;
          }
          
          // Create individual solution cards
          if(solutions.length > 0){
            solutions.forEach((sol, idx) => {
              const nameMatch = sol.match(/(?:Solution|Remediation|Recommendation)\s*\d+[:\-]\s*([^\n(*]+)/i);
              const solName = nameMatch ? nameMatch[1].trim() : `Solution ${idx + 1}`;
              output += `<div class="solution-card"><div class="solution-title">üîß ${solName}</div><div class="solution-content">${marked.parse(sol)}</div></div>`;
            });
          } else {
            output += `<div class="solution-card"><div class="solution-title">üîß Remediation Solutions</div><div class="solution-content">${marked.parse(solutionSection)}</div></div>`;
          }
        } else {
          // Last resort: render as normal markdown
          output = marked.parse(text);
        }
      }
      
      mdEl.innerHTML = output;
    }

    async function toBase64Compressed(file, maxDim=1600, quality=0.85){
      const dataUrl = await new Promise((resolve,reject)=>{
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
      // Draw to canvas to downscale
      const img = new Image();
      img.src = dataUrl;
      await img.decode();
      const scale = Math.min(1, maxDim / Math.max(img.width, img.height));
      const w = Math.max(1, Math.round(img.width * scale));
      const h = Math.max(1, Math.round(img.height * scale));
      const canvas = document.createElement('canvas');
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, w, h);
      const mime = (file.type && file.type !== 'image/png') ? 'image/jpeg' : file.type || 'image/jpeg';
      const out = canvas.toDataURL(mime, quality);
      return { dataUrl: out, mime };
    }
  </script>
</body>
</html>

